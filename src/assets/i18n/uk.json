{
	"CHRONICLE_LIBRARY": {
		"CONGRATULATIONS": "Чудово, юний герой! Ти успішно навів порядок у Бібліотеці Хронік. Тепер ти знаєш, як сортувати дані. Готуйся до наступного випробування - захисту міського муру від нападу!",
		"DESCRIPTION": {
			"EXPECTED_RESULT": {
				"RESULT1_TITLE": "Відсортований спсиок книг"
			},
			"INTRO": "Бібліотека Хронік зберігає знання століть, але через магічний збій книги перемішалися. Твоє завдання - відсортувати їх за роком видання. Використовуй для цього швидке сортування (Quick Sort). Щасти, юний герой!",
			"PARAMETERS": {
				"PARAMETER1_TITLE": "Список книг"
			}
		},
		"HINT": {
			"DESCRIPTION": {
				"ITEM1": "Quick Sort (швидке сортування) - це алгоритм сортування, який використовує метод «розділяй і володарюй». Він працює так: спочатку обирається опорний елемент (pivot) з масиву. Потім масив ділиться на дві частини: елементи, менші за опорний, і елементи, більші або рівні опорному. Після цього рекурсивно застосовується той самий процес до кожної з двох частин. Наприкінці об'єднуються відсортовані частини для отримання остаточного відсортованого масиву."
			},
			"PECULIARITIES": {
				"ITEM1": "Ефективність: У середньому і на практиці працює швидше за багато інших сортувань (O(n log n)), хоча в гіршому випадку (O(n^2)) може бути повільнішим.",
				"ITEM2": "Нестійкість: Не зберігає порядок рівних елементів.",
				"ITEM3": "Рекурсивність: Заснований на рекурсивному підході, що може вимагати додаткової пам'яті для стека викликів.",
				"ITEM4": "Внутрішнє сортування: Працює «на місці» (in-place), тобто не потребує додаткової пам'яті для зберігання елементів."
			}
		},
		"INTRO": "Тепер, коли ти опанував основи пошуку шляху, настав час навчитися впорядковувати інформацію. У Бібліотеці Хронік панує хаос - книжки розкидані всюди, і нам потрібно їх відсортувати. Ти будеш використовувати алгоритми сортування, щоб привести бібліотеку до ладу.",
		"NAME": "Бібліотека Хронік"
	},
	"CITY_WALL": {
		"CONGRATULATIONS": "Ти успішно знайшов оптимальний розподіл захисників, і наша столиця тепер максимально захищена. Твоє застосування динамічного програмування допомогло нам уникнути поразки. Ти справді гідний титулу справжнього майстра алгоритмів! Готуйся до нових викликів, які чекають на тебе попереду!",
		"DESCRIPTION": {
			"EXPECTED_RESULT": {
				"RESULT1_TITLE": "Розподіл"
			},
			"INTRO": "Наші стіни атакує різне число ворогів, а кожен клас захисників володіє силою, що визначає його ефективність у бою. Так, одиниця сили захисника визначає кількість ворогів, яку він може знешкодити. Твоє завдання - знайти оптимальний розподіл захисників по міських мурах, за якого на кожній з мурів буде мінімальна кількість захисників, здатна знешкодити ворога.",
			"PARAMETERS": {
				"PARAMETER1_TITLE": "Список захисників",
				"PARAMETER2_TITLE": "Мури"
			}
		},
		"HINT": {
			"DESCRIPTION": {
				"ITEM1": "Алгоритм всередині функції minDefenders використовує метод динамічного програмування для знаходження мінімальної кількості захисників, необхідних для захисту від певної кількості ворогів. У цьому алгоритмі створюється масив dp, де dp[i] зберігає мінімальну кількість захисників, необхідних для захисту від i ворогів.",
				"ITEM2": "Створюється масив dp розміром enemiesAmount + 1, заповнений значенням Number.MAX_SAFE_INTEGER, що символізує нескінченність. Це значення означає, що кількість захисників для даної кількості ворогів поки що не визначено. dp[0] встановлюється в 0, оскільки для захисту від 0 ворогів захисники не потрібні.",
				"ITEM2_TITLE": "Ініціалізація",
				"ITEM3": "dp: Для кожної кількості ворогів від 1 до enemiesAmount розглядаються всі доступні захисники. Якщо сила захисника менша або дорівнює поточній кількості ворогів, значення dp оновлюється з урахуванням мінімального числа захисників.",
				"ITEM3_TITLE": "Заповнення масиву",
				"ITEM4": "Повертається значення dp[enemiesAmount], яке представляє мінімальну кількість захисників для захисту від enemiesAmount ворогів.",
				"ITEM4_TITLE": "Результат"
			},
			"PECULIARITIES": {
				"ITEM1": "Динамічне програмування. Використовує метод динамічного програмування для оптимального розв'язання задачі, зберігаючи результати підзадач у масиві dp.",
				"ITEM2": "Оптимізація. Алгоритм оптимізує кількість захисників, розглядаючи кожного захисника і оновлюючи мінімальну кількість необхідну для кожної проміжної суми ворогів.",
				"ITEM3": "Часова складність. O(enemiesAmount * n), де n - кількість захисників.",
				"ITEM4": "Просторова складність. O(enemiesAmount), оскільки використовується масив для зберігання результатів підзадач."
			}
		},
		"INTRO": "Ворог наближається до нашої столиці, і ми повинні бути готові захистити її. Твоє завдання - знайти оптимальний розподіл захисників по міських мурах таким чином, щоб забезпечити максимальний захист, враховуючи загрозу, що нависла над кожною зі стін, і класи захисників. Використовуй динамічне програмування для вирішення цього складного завдання.",
		"NAME": "Міські мури"
	},
	"CODE_EDITOR": {
		"RUN_CODE": "Запустити код"
	},
	"COMMON": {
		"BUTTONS": {
			"BACK": "Назад",
			"NEXT": "Далі",
			"START": "Розпочати"
		},
		"FEEDBACK_PAGE": "На сторінку обговорення",
		"LOADING": "Завантаження..."
	},
	"CONGRATULATIONS": {
		"HEADLINE": "Вітаємо!",
		"LEAVE_FEEDBACK": "Ваш відгук важливий для нас! Це демо версія квесту, і робота над іншими рівнями триває. Будь ласка, поділіться своїми враженнями та побажаннями на нашій сторінці обговорень.",
		"PARAGRAPH": "Вітаю тебе, юний герою, твою подорож завершено, але попереду ще безліч пригод!",
		"START_OVER": "Почати спочатку"
	},
	"DEVICE_WARNING": {
		"HEADLINE": "Лише настільні пристрої",
		"PARAGRAPH": "Це додаток для написання коду, тому для зручності користувачів він доступний тільки на настільних пристроях. Будь ласка, зайдіть до нас на зі свого комп'ютера, щоб отримати доступ до додатка."
	},
	"MAZE_OF_KNOWLEDGE": {
		"CONGRATULATIONS": "Чудово, юний герою! Ти успішно знайшов шлях через Лабіринт знань, використовуючи пошук у ширину. Тепер ти розумієш, як алгоритми пошуку можуть допомогти тобі в подорожі.",
		"DESCRIPTION": {
			"INTRO": "Лабіринт знань - це місце, де кожна кімната з'єднана з іншими коридорами. Твоє завдання - знайти найкоротший шлях від входу до виходу, використовуючи алгоритми пошуку шляху. Щасти тобі, юний герою!",
			"PARAMETERS": {
				"PARAMETER1": "Вхід до лабіринту - кімната A",
				"PARAMETER2": "Вихід із лабіринту - кімната F",
				"PARAMETER3_TITLE": "Граф лабіринту"
			}
		},
		"HINT": {
			"DESCRIPTION": {
				"ITEM1": "Алгоритм пошуку в ширину (BFS) використовується для обходу або пошуку в графах і деревах. Він починається з вихідної вершини і досліджує всі її сусідні вершини на одному рівні перед переходом до вершин наступного рівня. У процесі обходу він послідовно досліджує всі вершини, забезпечуючи, що всі вузли на поточному рівні досліджуються перед переходом на глибший рівень. Це робить BFS корисним для пошуку найкоротшого шляху в графах без зважених ребер."
			},
			"PECULIARITIES": {
				"ITEM1": "Використовує чергу для управління вузлами, які необхідно відвідати.",
				"ITEM2": "Гарантує знаходження найкоротшого шляху (мінімальна кількість пройдених вузлів на шляху) у графах із не зваженими ребрами."
			}
		},
		"INTRO": "Ласкаво просимо в Алгорію, юний герою. Я Майстер Едгар, і я навчу тебе основ структур даних та алгоритмів. Наше перше випробування - Лабіринт знань. Цей лабіринт зберігає секрети нашої давньої магії, і щоб пройти його, тобі потрібно використовувати алгоритми пошуку шляху.",
		"NAME": "Лабіринт знань"
	},
	"ONBOARDING": {
		"CHOOSE_LANGUAGE": "Оберіть мову",
		"STEP1": {
			"PARAGRAPH1": "У далекому фентезійному королівстві Алгоріа, відомому своїми чудесами магії та науки, настали темні часи. Зловісний загарбник, маг Крифтон, використовує стародавні й забуті алгоритми для створення хаосу та руйнування."
		},
		"STEP2": {
			"PARAGRAPH1": "Ти, юний герой, що навчається мистецтву алгоритмів і структур даних, маєш пройти серію випробувань і перемогти Крифтона, щоб відновити мир у королівстві."
		}
	},
	"PREFACE": {
		"DESCRIPTION": "Опис",
		"DESCRIPTION_TEXT": "Алгоритмічний квест - це пригодницька гра, де гравцеві потрібно розв'язувати головоломки та виконувати завдання, використовуючи різні структури даних та алгоритми. Робота над квестом триває, тому наразі доступні перші три рівні.",
		"GOAL": "Мета гри",
		"GOAL_DETAILS": "Гравцеві необхідно врятувати королівство від загарбників, подорожуючи фентезійним світом і зустрічаючи різні перешкоди."
	},
	"TASK_DISPLAY": {
		"ALGORITHM_DESCRIPTION": "Опис",
		"EXPECTED_RESULT": "Очікуваний результат",
		"HELP_BUTTON": "Попросити про допомогу",
		"IM_RONAN": "Я Ронан, головний коваль Алгорії. Потрібна допомога?",
		"INITIAL_DATA": "Вихідні дані",
		"PECULIARITIES": "Основні властивості",
		"PSEUDOCODE": "Псевдокод/Структурна схема"
	},
	"TEST_RUN_RESULTS": {
		"IT_WORKED": "Вдалося!",
		"NOT_WORKED": "Не спрацювало.",
		"RESULT_PLACEHOLDER": "Тут відобразиться результат",
		"WANNA_SAVE_PROGRESS": "Хочете зберегти свій прогрес і перейти до наступного квесту?",
		"YOUR_CODE_OUTPUT": "Ваш код повернув"
	}
}

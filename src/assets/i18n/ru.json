{
	"CHRONICLE_LIBRARY": {
		"CONGRATULATIONS": "Отлично, юный герой! Ты успешно навёл порядок в Библиотеке Хроник. Теперь ты знаешь, как сортировать данные. Готовься к следующему испытанию — защите городской стены от нападения!",
		"DESCRIPTION": {
			"EXPECTED_RESULT": {
				"RESULT1_TITLE": "Отсортированный список книг"
			},
			"INTRO": "Библиотека Хроник хранит знания веков, но из-за магического сбоя книги перемешались. Твоя задача — отсортировать их по году издания. Используй для этого быструю сортировку (Quick Sort). Удачи, юный герой!",
			"PARAMETERS": {
				"PARAMETER1_TITLE": "Список книг"
			}
		},
		"HINT": {
			"DESCRIPTION": {
				"ITEM1": "Quick Sort (быстрая сортировка) — это алгоритм сортировки, который использует метод \"разделяй и властвуй\". Он работает следующим образом: сначала выбирается опорный элемент (pivot) из массива. Затем массив делится на две части: элементы, меньшие опорного, и элементы, большие или равные опорному. После этого рекурсивно применяется тот же процесс к каждой из двух частей. В конце объединяются отсортированные части для получения окончательного отсортированного массива."
			},
			"PECULIARITIES": {
				"ITEM1": "Эффективность: В среднем и на практике работает быстрее многих других сортировок (O(n log n)), хотя в худшем случае (O(n^2)) может быть медленнее.",
				"ITEM2": "Неустойчивость: Не сохраняет порядок равных элементов.",
				"ITEM3": "Рекурсивность: Основан на рекурсивном подходе, что может требовать дополнительной памяти для стека вызовов.",
				"ITEM4": "Внутренняя сортировка: Работает \"на месте\" (in-place), т.е. не требует дополнительной памяти для хранения элементов."
			}
		},
		"INTRO": "Теперь, когда ты освоил основы поиска пути, пришло время научиться упорядочивать информацию. В Библиотеке Хроник царит хаос — книги разбросаны повсюду, и нам нужно их отсортировать. Ты будешь использовать алгоритмы сортировки, чтобы привести библиотеку в порядок.",
		"NAME": "Библиотека Хроник"
	},
	"CITY_WALL": {
		"CONGRATULATIONS": "Ты успешно нашел оптимальное распределение защитников, и наша столица теперь максимально защищена. Твое применение динамического программирования помогло нам избежать поражения. Ты действительно достоин титула настоящего мастера алгоритмов! Готовься к новым вызовам, которые ждут тебя впереди!",
		"DESCRIPTION": {
			"EXPECTED_RESULT": {
				"RESULT1_TITLE": "Распределение"
			},
			"INTRO": "Наши стены атакует различное число врагов, а каждый класс защитников обладает силой, определяющим его эффективность в бою. Так, единица силы защитника определяет количество врагов, которое он может обезвредить. Твоя задача — найти оптимальное распределение защитников по городским стенам, при котором на каждой из стен будет минимальное количество защитников способное обезвредить врага.",
			"PARAMETERS": {
				"PARAMETER1_TITLE": "Список защитников",
				"PARAMETER2_TITLE": "Стены"
			}
		},
		"HINT": {
			"DESCRIPTION": {
				"ITEM1": "Алгоритм внутри функции minDefenders использует метод динамического программирования для нахождения минимального числа защитников, необходимых для защиты от определенного количества врагов. В данном алгоритме создается массив dp, где dp[i] хранит минимальное количество защитников, необходимых для защиты от i врагов.",
				"ITEM2": "Создается массив dp размером enemiesAmount + 1, заполненный значением Number.MAX_SAFE_INTEGER, что символизирует бесконечность. Это значение означает, что количество защитников для данного количества врагов пока не определено. dp[0] устанавливается в 0, так как для защиты от 0 врагов защитники не требуются.",
				"ITEM2_TITLE": "Инициализация",
				"ITEM3": "dp: Для каждого количества врагов от 1 до enemiesAmount рассматриваются все доступные защитники. Если сила защитника меньше или равна текущему количеству врагов, значение dp обновляется с учетом минимального числа защитников.",
				"ITEM3_TITLE": "Заполнение массива",
				"ITEM4": "Возвращается значение dp[enemiesAmount], которое представляет минимальное количество защитников для защиты от enemiesAmount врагов.",
				"ITEM4_TITLE": "Результат"
			},
			"PECULIARITIES": {
				"ITEM1": "Динамическое программирование. Использует метод динамического программирования для оптимального решения задачи, сохраняя результаты подзадач в массиве dp.",
				"ITEM2": "Оптимизация. Алгоритм оптимизирует количество защитников, рассматривая каждого защитника и обновляя минимальное количество необходимое для каждой промежуточной суммы врагов.",
				"ITEM3": "Временная сложность. O(enemiesAmount * n), где n — количество защитников.",
				"ITEM4": "Пространственная сложность. O(enemiesAmount), так как используется массив для хранения результатов подзадач."
			}
		},
		"INTRO": "Враг приближается к нашей столице, и мы должны быть готовы защитить её. Твоя задача — найти оптимальное распределение защитников по городским стенам таким образом, чтобы обеспечить максимальную защиту, учитывая угрозу нависшую над каждой из стен и классы защитников. Используй динамическое программирование для решения этой сложной задачи.",
		"NAME": "Городские стены"
	},
	"CODE_EDITOR": {
		"RUN_CODE": "Запустить код"
	},
	"COMMON": {
		"BUTTONS": {
			"BACK": "Назад",
			"NEXT": "Далее",
			"START": "Начать"
		},
		"LOADING": "Загрузка..."
	},
	"CONGRATULATIONS": {
		"HEADLINE": "Поздравляем!",
		"PARAGRAPH": "Поздравляю тебя, юный герой, твое путешествие завершено, но впереди еще множество приключений!",
		"START_OVER": "Начать сначала"
	},
	"DEVICE_WARNING": {
		"HEADLINE": "Только настольные устройства",
		"PARAGRAPH": "Это приложение для написания кода, поэтому для удобства пользователей оно доступно только на настольных устройствах. Пожалуйста, зайдите к нам на со своего компьютера, чтобы получить доступ к приложению."
	},
	"MAZE_OF_KNOWLEDGE": {
		"CONGRATULATIONS": "Превосходно, юный герой! Ты успешно нашёл путь через Лабиринт знаний, используя поиск в ширину. Теперь ты понимаешь, как алгоритмы поиска могут помочь тебе в путешествии. Готовься к следующему испытанию — организации Библиотеки Хроник!",
		"DESCRIPTION": {
			"INTRO": "Лабиринт знаний — это место, где каждая комната соединена с другими коридорами. Твоя задача — найти кратчайший путь от входа до выхода, используя алгоритмы поиска пути. Удачи, юный герой!",
			"PARAMETERS": {
				"PARAMETER1": "Вход в лабиринт - комната A",
				"PARAMETER2": "Выход из лабиринта - комната F",
				"PARAMETER3_TITLE": "Граф лабиринта"
			}
		},
		"HINT": {
			"DESCRIPTION": {
				"ITEM1": "Алгоритм поиска в ширину (BFS) используется для обхода или поиска в графах и деревьях. Он начинается с исходной вершины и исследует все её соседние вершины на одном уровне перед переходом к вершинам следующего уровня. В процессе обхода он последовательно исследует все вершины, обеспечивая, что все узлы на текущем уровне исследуются перед переходом на более глубокий уровень. Это делает BFS полезным для поиска кратчайшего пути в графах без взвешенных рёбер."
			},
			"PECULIARITIES": {
				"ITEM1": "Использует очередь для управления узлами, которые необходимо посетить.",
				"ITEM2": "Гарантирует нахождение кратчайшего пути (минимальное количество пройденых узлов на пути) в графах с не взвешенными ребрами."
			}
		},
		"INTRO": "Добро пожаловать в Алгорию, юный герой. Я Мастер Эдгар, и я обучу тебя основам структур данных и алгоритмов. Наше первое испытание — Лабиринт знаний. Этот лабиринт хранит секреты нашей древней магии, и чтобы пройти его, тебе нужно использовать алгоритмы поиска пути.",
		"NAME": "Лабиринт знаний"
	},
	"ONBOARDING": {
		"CHOOSE_LANGUAGE": "Выберите язык",
		"STEP1": {
			"PARAGRAPH1": "В далеком фэнтезийном королевстве Алгориа, известном своими чудесами магии и науки, наступили тёмные времена. Зловещий захватчик, маг Крифтон, использует древнюю и забытые алгоритмы для создания хаоса и разрушения."
		},
		"STEP2": {
			"PARAGRAPH1": "Ты, юный герой, обучающийся искусству алгоритмов и структур данных, должен пройти серию испытаний и победить Крифтона, чтобы восстановить мир в королевстве."
		}
	},
	"PREFACE": {
		"DESCRIPTION": "Описание",
		"DESCRIPTION_TEXT": "Алгоритмический квест — это приключенческая игра, где игроку нужно решать головоломки и выполнять задачи, используя различные структуры данных и алгоритмы. Игрок путешествует по фэнтезийному миру, встречая различные препятствия, которые требуют применения алгоритмов для их преодоления.",
		"GOAL": "Цель игры",
		"GOAL_DETAILS": "Игроку необходимо спасти королевство от захватчиков, выполняя серию квестов. Каждый квест требует решения головоломок с использованием конкретных структур данных и алгоритмов."
	},
	"TASK_DISPLAY": {
		"ALGORITHM_DESCRIPTION": "Описание",
		"EXPECTED_RESULT": "Ожидаемый результат",
		"HELP_BUTTON": "Попросить о помощи",
		"IM_RONAN": "Я Ронан, главный кузнец Алгории. Нужна помощь?",
		"INITIAL_DATA": "Исходные данные",
		"PECULIARITIES": "Основные особенности",
		"PSEUDOCODE": "Псевдокод/Структурная схема"
	},
	"TEST_RUN_RESULTS": {
		"IT_WORKED": "Получилось!",
		"NOT_WORKED": "Не сработало.",
		"RESULT_PLACEHOLDER": "Здесь отобразится результат",
		"WANNA_SAVE_PROGRESS": "Хотите сохранить свой прогресс и перейти к следующему квесту?",
		"YOUR_CODE_OUTPUT": "Ваш код вернул"
	}
}
